/**
 * CVE Matcher
 * Matches discovered software/versions from network scans to CVEs in NVD database
 */

import { searchCves } from "./nvd-api.js";

export interface DiscoveredSoftware {
  product: string;
  version?: string;
  service?: string;
  port?: number;
}

/**
 * Extract software name and version from Nmap service string
 * Examples:
 * - "Apache httpd 2.4.41" -> { product: "Apache httpd", version: "2.4.41" }
 * - "nginx 1.18.0" -> { product: "nginx", version: "1.18.0" }
 * - "OpenSSH 8.2" -> { product: "OpenSSH", version: "8.2" }
 */
export function parseServiceVersion(serviceString: string): DiscoveredSoftware | null {
  if (!serviceString || serviceString.trim().length === 0) {
    return null;
  }

  // Common patterns:
  // "Apache httpd 2.4.41"
  // "nginx 1.18.0"
  // "OpenSSH 8.2p1"
  // "MySQL 8.0.21"
  // "WordPress 5.8"
  
  const trimmed = serviceString.trim();
  
  // Try to extract version (usually at the end, format: numbers and dots)
  const versionMatch = trimmed.match(/(\d+\.\d+(?:\.\d+)?(?:[a-z]\d+)?(?:\s+\(.*?\))?)$/);
  let version: string | undefined;
  let product: string;
  
  if (versionMatch) {
    version = versionMatch[1].trim();
    product = trimmed.substring(0, versionMatch.index).trim();
  } else {
    // No version found, use entire string as product
    product = trimmed;
  }
  
  // Clean up product name (remove common suffixes)
  product = product
    .replace(/\s+http\s+server$/i, "")
    .replace(/\s+web\s+server$/i, "")
    .trim();
  
  if (product.length === 0) {
    return null;
  }
  
  return {
    product,
    version,
  };
}

/**
 * Find CVEs for discovered software
 */
export async function findCvesForSoftware(
  software: DiscoveredSoftware,
  limit: number = 10
): Promise<Array<{ cveId: string; description: string; severity?: number }>> {
  const searchTerms: string[] = [];
  
  // Build search terms
  if (software.version) {
    // Search for product + version
    searchTerms.push(`${software.product} ${software.version}`);
  }
  // Also search for just the product (broader search)
  searchTerms.push(software.product);
  
  const allCves = new Map<string, { cveId: string; description: string; severity?: number }>();
  
  // Search for each term
  for (const term of searchTerms) {
    try {
      const results = await searchCves(term, limit);
      
      for (const cve of results) {
        // Only add if not already present
        if (!allCves.has(cve.cveId)) {
          allCves.set(cve.cveId, {
            cveId: cve.cveId,
            description: cve.description,
            severity: cve.severity,
          });
        }
      }
      
      // Small delay to respect rate limits
      await new Promise((resolve) => setTimeout(resolve, 500));
    } catch (err) {
      console.error(`Failed to search CVEs for "${term}":`, err);
    }
  }
  
  return Array.from(allCves.values());
}

/**
 * Match discovered services to CVEs
 */
export async function matchServicesToCves(
  services: Array<{ service: string; version?: string; product?: string }>
): Promise<Map<string, Array<{ cveId: string; description: string; severity?: number }>>> {
  const results = new Map<string, Array<{ cveId: string; description: string; severity?: number }>>();
  
  for (const svc of services) {
    // Build software identifier
    const softwareString = svc.product || svc.service || "";
    const versionString = svc.version || "";
    const fullString = versionString ? `${softwareString} ${versionString}` : softwareString;
    
    if (!fullString || fullString.trim().length === 0) {
      continue;
    }
    
    const parsed = parseServiceVersion(fullString);
    if (!parsed || !parsed.product) {
      continue;
    }
    
    // Find CVEs for this software
    const cves = await findCvesForSoftware(parsed, 5); // Limit to 5 CVEs per service
    
    if (cves.length > 0) {
      const key = `${svc.service || "unknown"}:${svc.port || "unknown"}`;
      results.set(key, cves);
    }
  }
  
  return results;
}

