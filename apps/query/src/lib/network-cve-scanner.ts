/**
 * Network CVE Scanner
 * Combines Nmap scanning with NVD CVE matching to identify vulnerabilities
 */

import { scanNetwork, type ScanOptions, type ScanResult } from "./network-scan.js";
import { matchServicesToCves } from "./cve-matcher.js";

export interface NetworkCveScanOptions extends ScanOptions {
  matchCves?: boolean; // Whether to match discovered services to CVEs
  onProgress?: (message: string) => void;
}

export interface NetworkCveScanResult extends ScanResult {
  matchedCves?: Array<{
    service: string;
    port: number;
    product?: string;
    version?: string;
    cves: Array<{
      cveId: string;
      description: string;
      severity?: number;
    }>;
  }>;
}

/**
 * Scan network and match discovered services to CVEs
 */
export async function scanNetworkWithCveMatching(
  options: NetworkCveScanOptions
): Promise<NetworkCveScanResult[]> {
  const { matchCves = true, onProgress, ...scanOptions } = options;
  
  onProgress?.("üîç Step 1: Scanning network with Nmap...");
  onProgress?.("   Discovering services and versions...");
  
  // Run Nmap scan
  const scanResults = await scanNetwork(scanOptions);
  
  onProgress?.(`‚úÖ Found ${scanResults.length} host(s) with ${scanResults.reduce((sum, h) => sum + h.services.length, 0)} service(s)`);
  
  if (!matchCves || scanResults.length === 0) {
    return scanResults.map(r => ({ ...r, matchedCves: [] }));
  }
  
  onProgress?.("üîç Step 2: Matching discovered services to CVEs...");
  onProgress?.("   Querying NVD database for vulnerabilities...");
  
  // For each host, match services to CVEs
  const results: NetworkCveScanResult[] = [];
  
  for (const host of scanResults) {
    if (host.services.length === 0) {
      results.push({ ...host, matchedCves: [] });
      continue;
    }
    
    onProgress?.(`   Analyzing ${host.services.length} service(s) on ${host.host}...`);
    
    // Prepare services for CVE matching
    const services = host.services.map(svc => ({
      service: svc.service,
      version: svc.version,
      product: svc.product,
      port: svc.port,
    }));
    
    // Match to CVEs
    const cveMap = await matchServicesToCves(services);
    
    // Build matched CVEs array
    const matchedCves: NetworkCveScanResult["matchedCves"] = [];
    
    for (const svc of host.services) {
      const key = `${svc.service}:${svc.port}`;
      const cves = cveMap.get(key);
      
      if (cves && cves.length > 0) {
        matchedCves.push({
          service: svc.service,
          port: svc.port,
          product: svc.product,
          version: svc.version,
          cves,
        });
        
        onProgress?.(`   ‚ö†Ô∏è  Found ${cves.length} CVE(s) for ${svc.service}${svc.version ? ` ${svc.version}` : ""} on port ${svc.port}`);
      }
    }
    
    // Also add CVEs to the vulnerabilities array
    const allCves = new Map<string, { cve: string; severity: number; description: string }>();
    
    for (const matched of matchedCves) {
      for (const cve of matched.cves) {
        if (!allCves.has(cve.cveId)) {
          allCves.set(cve.cveId, {
            cve: cve.cveId,
            severity: cve.severity || 5.0,
            description: cve.description,
          });
        }
      }
    }
    
    // Merge with existing vulnerabilities
    const existingVulns = new Set(host.vulnerabilities.map(v => v.cve).filter(Boolean));
    for (const [cveId, vuln] of allCves) {
      if (!existingVulns.has(cveId)) {
        host.vulnerabilities.push(vuln);
      }
    }
    
    results.push({
      ...host,
      matchedCves,
    });
  }
  
  const totalCves = results.reduce((sum, r) => sum + (r.matchedCves?.length || 0), 0);
  onProgress?.(`‚úÖ CVE matching complete: Found ${totalCves} service(s) with known vulnerabilities`);
  
  return results;
}

